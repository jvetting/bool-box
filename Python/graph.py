import sys
import config
#from util import *
import spotipy
import spotipy.util as util
import time
import json
import pandas as pd
#from tqdm import tqdm
import matplotlib.pyplot as plt
plt.style.use('classic')
import numpy as np
import seaborn as sns

global args
global token
global playlist_uri
global scope
global analyze
global num

token = ''
scope = 'user-library-read, user-read-playback-state, user-modify-playback-state'

#Modify this to get more info (may time out on large playlists)
analyze = False

num = 10

plt.close("all")
sns.set()
sns.set_theme()

#HOW TO RUN ON COMMANDLINE:
#When using command line, playlist link must always be used and placed as last arg

#To analyze N tracks from a specific playlist: 'N True <INSERT PLAYLIST LINK HERE>'
#To only get N tracks from a specific playlist: 'N <INSERT PLAYLIST LINK HERE'>
#To only get from a specific playlist: '<INSERT PLAYLIST LINK HERE>'
#DEFAULT: To get playlist specified in config.py: Empty commandline

#Sets up spotipy authorization token
def spotStart():
    print('spotStart called')
    global token
    token = util.prompt_for_user_token(config.username,
                                       scope,
                                       client_id=config.SP_CLIENT_ID,
                                       client_secret=config.SP_CLIENT_SECRET,
                                       redirect_uri=config.SP_REDIRECT_URI)
    print('token created as ', token)

#Iterates through playlist and returns a list of lists containing each track's artist name, track name, album release date, and track popularity
def iterate_tracks(results, analyze):
    features = []
    #DO THIS FOR PROGRESS BARS
    #for i, item in enumerate(tqdm(results['items'])):

    for i, item in enumerate(results['items']):
        track = item['track']
        #Check if track was uploaded from a local file (local files don't have features)
        if not track['is_local']:
            album = sp.album(track['album']['id'])
            print(
                "   %d %32.32s %s   %d" %
                (i, track['artists'][0]['name'], track['name'], track['popularity']))
            info = [track['artists'][0]['name'], track['name'], album['release_date'], track['popularity']]
            if analyze:
                analysis = list(sp.audio_features(track['uri'])[0].values())
                features.append(info + analysis)
            else:
                features.append(info)
    return features

#Prints the list of lists generated by iterate_tracks()
def show_features(results):
    for i, item in enumerate(results):
        print(
            "   %d %s" %
            (i, results[i]))

#Assembles a data frame
def df_tracks(tracklist, analyze):
    if(analyze):
        df = pd.DataFrame(tracklist, columns=['artist',
         'track_name',
         'release_date', 'popularity'] + list(sp.audio_features('7tr2za8SQg2CI8EDgrdtNl')[0].keys()))

        df.rename(columns={'uri':'song_uri'}, inplace=True)

        #df.drop_duplicates(subset=['artist', 'track', 'release_date'], inplace=True)

        # Reorder the cols to have identifiers first, auditory features last
        cols = ['artist', 'track_name', 'release_date', 'popularity'
         'analysis_url', 'type', 'danceability', 'energy', 'key',  'loudness', 'mode', 'speechiness',
         'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'duration_ms', 'time_signature']
        return df
    else:
        df = pd.DataFrame(tracklist, columns=['artist',
         'track_name',
         'release_date', 'popularity'])

        # Reorder the cols to have identifiers first, auditory features last
        cols = ['artist', 'track_name', 'release_date', 'popularity']
        return df

#Prints n artists with highest occurences
def df_nlargest(df, n):
    freq = df.groupby([df.index, 'artist']).count().plot(kind='bar')
    print(freq)

#Graphs n artists in df by occurences
def graph_nlargest(df, n):
    ax = sns.countplot(x="artist", data=df, order=df.artist.value_counts().iloc[:n].index)
    plt.show()

print ('Python program is starting...')
if __name__ == '__main__':
    args = sys.argv
    print ('Args: ', str(args))

    #Get num, analyze and playlist link from commandline
    if len(args) > 3:
        num = int(args[1])
        analyze = args[2]
        playlist_uri = args[3]
    #Else get num and playlist link from commandline
    elif len(args) > 2:
        num = int(args[1])
        playlist_uri = args[2]
    #Else only get playlist link from commandline
    elif len(args) > 1:
        playlist_uri = args[1]
    #Else, get playlist link from config file
    else:
        playlist_uri = config.playlist_uri

    spotStart()
    sp = spotipy.Spotify(auth=token)
    playlist = sp.playlist(playlist_uri, market=None, additional_types=('track',))
    print("Playlist: ", playlist['name'])
    results = sp.playlist(playlist['id'], fields="tracks,next")

    #Make list of playlist's tracks
    tracks = results['tracks']
    #Create list of first tracks in tracks
    features = iterate_tracks(tracks, analyze)
    #Since sp.playlist returns first 100 tracks, iterate through tracks['next'] to get next 100
    while tracks['next']:
        tracks = sp.next(tracks)
        features.extend(iterate_tracks(tracks, analyze))

    #DEBUG
    #show_features(features)

    #Build data frame
    df = df_tracks(features, analyze)

    #Graph by artist occurences
    graph_nlargest(df, num)
